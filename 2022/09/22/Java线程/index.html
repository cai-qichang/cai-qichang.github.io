

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <!-- 通过 CDN 引入霞鹜文楷字体 -->
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/me.png">
  <link rel="icon" href="/img/me.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="caiqichang">
  <meta name="keywords" content="">
  
    <meta name="description" content="java 并发线程相关线程状态  新建(NEW): 创建后尚未启动。 可运行(RUNABLE): 正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度(例如处理器资源)，资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。 阻塞(BLOCKED): 请求获取 monitor lock 从而进入 synchron">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程">
<meta property="og:url" content="https://cai-qichang.github.io/2022/09/22/Java%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="caiqichang&#39;s Blog">
<meta property="og:description" content="java 并发线程相关线程状态  新建(NEW): 创建后尚未启动。 可运行(RUNABLE): 正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度(例如处理器资源)，资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。 阻塞(BLOCKED): 请求获取 monitor lock 从而进入 synchron">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadState2.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadstate.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadState21.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadPool.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadPoolProcess.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadpoolsetSolution.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadpool1.jpg">
<meta property="article:published_time" content="2022-09-22T11:51:00.000Z">
<meta property="article:modified_time" content="2024-10-13T05:21:07.836Z">
<meta property="article:author" content="caiqichang">
<meta property="article:tag" content="Java线程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadState2.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java线程 - caiqichang&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"cai-qichang.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>caiqichang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/yueqiu.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java线程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-22 19:51" pubdate>
          2022年9月22日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          171 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java线程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="java-并发线程相关"><a href="#java-并发线程相关" class="headerlink" title="java 并发线程相关"></a>java 并发线程相关</h1><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadState2.jpg" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<ul>
<li>新建(NEW): 创建后尚未启动。</li>
<li>可运行(RUNABLE): 正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度(例如处理器资源)，资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</li>
<li>阻塞(BLOCKED): 请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</li>
<li>无限期等待(WAITING): 等待其它线程显式地唤醒。<ul>
<li>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<ul>
<li>限期等待(TIMED_WAITING): 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。<ul>
<li>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 &#x2F; 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<ul>
<li>死亡(TERMINATED): 可以是线程结束任务之后自己结束，或者产生了异常而结束。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadstate.png" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<h3 id="线程方法与状态切换"><a href="#线程方法与状态切换" class="headerlink" title="线程方法与状态切换"></a>线程方法与状态切换</h3><p><code>sleep</code> 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 <strong>TIMED-WATING</strong> 状态，而 wait()方法会导致当前线程进入 WATING 状态</p>
<p><code>wait</code> 方法，主动让出锁。</p>
<ol>
<li>不带时间常数的wait 方法进入WAITING状态。</li>
<li>带时间常数的wait 进入TIME-WAITING状态。</li>
</ol>
<p><code>yield</code> 方法，线程让步。 yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片</p>
<p><code>join</code>方法，当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p>
<blockquote>
<p>join方法可用于多线程的协作，如主子线程的协作，主线程等待子线程完成任务。<br>join 方法的状态转换与wait方法相同，带时间的进入TIME-WAITING状态，不带时间的进入WAITING状态。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;);<br>Thread6 thread1 = new Thread6();<br>thread1.setName(&quot;线程 B&quot;);<br>thread1.join();<br>System.out.println(&quot;这时 thread1 执行完毕之后才能执行主线程&quot;);<br></code></pre></td></tr></table></figure>

<h2 id="创建一个线程的开销"><a href="#创建一个线程的开销" class="headerlink" title="创建一个线程的开销"></a>创建一个线程的开销</h2><p>JVM 在背后帮我们做了哪些事情: </p>
<ol>
<li>它为一个线程栈分配内存，该栈为每个线程方法调用保存一个栈帧</li>
<li>每一栈帧由一个局部变量数组、返回值、操作数堆栈和常量池组成</li>
<li>一些支持本机方法的 jvm 也会分配一个本机堆栈</li>
<li>每个线程获得一个程序计数器，告诉它当前处理器执行的指令是什么</li>
<li>系统创建一个与Java线程对应的本机线程</li>
<li>将与线程相关的描述符添加到JVM内部数据结构中</li>
<li>线程共享堆和方法区域</li>
</ol>
<blockquote>
<p>用数据来说明创建一个线程(即便不干什么)需要多大空间呢？<br>答案是大约 1M 左右。<code>java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:+PrintNMTStatistics -version</code><br>用 Java8 的测试结果，19个线程，预留和提交的大概都是19000+KB，平均每个线程大概需要 1M 左右的大小</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadState21.jpg" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ul>
<li>callable 接口继承: 可以获取线程的返回值。</li>
</ul>
<blockquote>
<p>Future接口 相当于 Runnable接口<br>FutureTask类 类似于Thread类，最后执行调用都要使用Thread类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableThread</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        callable.start();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> futureTask.isDone();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> futureTask.isCancelled();<br>        <span class="hljs-comment">// while (!Thread.interrupted())，那么本次任务会一直执行，只有mayInterruptIfRunning=true</span><br>        futureTask.cancel(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 设置获取结果的等待时间,超时抛出timeOutException</span><br>        <span class="hljs-comment">// String s = futureTask.get(1, TimeUnit.SECONDS);</span><br>        <span class="hljs-comment">// 阻塞等待</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-comment">// do some job</span><br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;complete the job&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Runnable接口实现 与 继承Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OriThread</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableThread</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OriThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;this is the org thread!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;this is runnable thread&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="退出线程的方法"><a href="#退出线程的方法" class="headerlink" title="退出线程的方法"></a>退出线程的方法</h2><h3 id="虚拟机级别的中断方式"><a href="#虚拟机级别的中断方式" class="headerlink" title="虚拟机级别的中断方式"></a>虚拟机级别的中断方式</h3><ol>
<li>线程中使用一个静态的volatile的标志判断退出。</li>
<li>调用Executors的submit方法，获取线程上下文对象Future，调用cancel方法。(注: 无法中断正在试图获取synchronized锁或者试图执行I&#x2F;O操作的线程)IO的中断，关闭底层资源之后，任务将解除阻塞。如socket连接，调用socket的close 或者 system.in 的输入连接调用in.close().</li>
<li>调用ExecutorService的shutdown的方法。</li>
<li>通过检查中断状态Thread.interrupted()，主动调用Thread的interrupt方法实现。(注意处理的时候，如果线程已经调用了interrupt()，如果再调用sleep方法，将抛出interruptException的异常)</li>
</ol>
<ul>
<li>与Runnable相关: 主要是通过调用<code>Thread.interrupt</code>方法实现。</li>
<li>与Callable相关: 可以调用Future对象的cancel(true)方法。</li>
</ul>
<h3 id="基于ReentrantLock"><a href="#基于ReentrantLock" class="headerlink" title="基于ReentrantLock"></a>基于ReentrantLock</h3><p>ReentrantLock调用锁的<code>lockInterruptibly()</code>方法，</p>
<ol>
<li><code>lock()</code>, 拿不到lock就不罢休，不然线程就一直block。 </li>
<li><code>tryLock()</code>，马上返回，拿到lock就返回true，不然返回false。带时间限制的<code>tryLock()</code>，拿不到lock，就等一段时间，超时返回false。比较聪明的做法。</li>
<li><code>lockInterruptibly()</code>就稍微难理解一些。<br>先说说线程的打扰机制，每个线程都有一个 <em>打扰</em> 标志。这里分两种情况，</li>
</ol>
<ul>
<li>线程在sleep或wait、join， 此时如果别的进程调用此进程的 interrupt()方法，此线程会被唤醒并被要求处理InterruptedException；(thread在做IO操作时也可能有类似行为，见java thread api)</li>
<li>此线程在运行中，则不会收到提醒。但是 此线程的 “打扰标志”会被设置， 可以通过isInterrupted()查看并 作出处理。</li>
<li>结论: <code>lockInterruptibly()</code>和上面的第一种情况是一样的， 线程在请求lock并被阻塞时，如果被interrupt，则“此线程会被唤醒并被要求处理InterruptedException”。并且如果线程已经被interrupt，再使用lockInterruptibly的时候，此线程也会被要求处理interruptedException</li>
</ul>
<h3 id="中断标志Interrupt"><a href="#中断标志Interrupt" class="headerlink" title="中断标志Interrupt"></a>中断标志Interrupt</h3><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。 这个线程本身并不会因此而改变状态(如阻塞，终止等)。</p>
<ol>
<li>调用 <code>interrupt()</code>方法并不会中断一个正在运行的线程。也就是说处于 <code>Running</code> 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</li>
<li>若调用 <code>sleep()</code>而使线程处于<code>TIMED-WATING</code> 状态，这时调用 <code>interrupt()</code>方法，会抛出<code>InterruptedException</code>,从而使线程提前结束 <code>TIMED-WATING</code> 状态。</li>
<li>许多声明抛出 InterruptedException 的方法，抛出异常前，都会<strong>清除中断标识位</strong>，所以<strong>抛出异常后</strong>，调用 <code>isInterrupted()</code>方法将会返回 false</li>
<li>利用中断标识，可以调用 <code>thread.interrupt()</code>方法，在线程的 run 方法内部可以根据 <code>thread.isInterrupted()</code>的值来优雅的终止线程。</li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">/**<br> * Lock held on access to workers set and related bookkeeping.<br> * While we could use a concurrent set of some sort, it turns out<br> * to be generally preferable to use a lock. Among the reasons is<br> * that this serializes interruptIdleWorkers, which avoids<br> * unnecessary interrupt storms, especially during shutdown.<br> * Otherwise exiting threads would concurrently interrupt those<br> * that have not yet interrupted. It also simplifies some of the<br> * associated statistics bookkeeping of largestPoolSize etc. We<br> * also hold mainLock on shutdown and shutdownNow, for the sake of<br> * ensuring workers set is stable while separately checking<br> * permission to interrupt and actually interrupting.<br> */<br>private final ReentrantLock mainLock = new ReentrantLock();<br></code></pre></td></tr></table></figure>

<p>线程池的主要状态锁，对线程池状态(比如线程池大小、runState等)的改变都要使用这个锁</p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池的5种状态: Running、ShutDown、Stop、Tidying、Terminated。<br><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadPool.png" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<p>RUNNING</p>
<ol>
<li>状态说明: 线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 </li>
<li>状态切换: 线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态</li>
</ol>
<p>SHUTDOWN</p>
<ol>
<li>状态说明: 线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </li>
<li>状态切换: 调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</li>
</ol>
<p>STOP</p>
<ol>
<li>状态说明: 线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 </li>
<li>状态切换: 调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</li>
</ol>
<p>TIDYING</p>
<ol>
<li>状态说明: 当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </li>
<li>状态切换: 当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。</li>
</ol>
<p>TERMINATED</p>
<ol>
<li>状态说明: 线程池彻底终止，就变成TERMINATED状态。 </li>
<li>状态切换: 线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li>
</ol>
<h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p> 线程池的初始化: </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">/**<br> * 用给定的初始参数创建一个新的ThreadPoolExecutor。<br> */<br>public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量<br>                          int maximumPoolSize,//线程池的最大线程数<br>                          long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间<br>                          TimeUnit unit,//时间单位<br>                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列<br>                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可<br>                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务<br>                           )&#123;<br>.......<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>corePoolSize</code>: 核心线程数量，当有新任务在<code>execute()</code>方法提交时，会执行以下判断: </p>
<ol>
<li>如果运行的线程少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>
<li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当<code>workQueue</code>满时才创建新的线程去处理任务；</li>
<li>如果设置的<code>corePoolSize</code> 和 <code>maximumPoolSize</code>相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li>
<li>如果运行的线程数量大于等于<code>maximumPoolSize</code>，这时如果<code>workQueue</code>已经满了，则通过handler所指定的策略来处理任务</li>
<li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> –&gt; <code>workQueue</code> –&gt; <code>maximumPoolSize</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadPoolProcess.png" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<p>线程池拒绝策略</p>
<ol>
<li><code>ThreadPoolExecutor.AbortPolicy</code>: 抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>: 提交任务的线程自己去执行该任务</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>:  不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>:  此策略将丢弃最早的未处理的任务请求。</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waitmoon/p/13442193.html">线程池应用场景简介</a></li>
</ul>
<h3 id="线程池的队列-五种"><a href="#线程池的队列-五种" class="headerlink" title="线程池的队列 五种"></a>线程池的队列 五种</h3><ol>
<li><code>Executors.newFixedThreadPool()</code>: <code>new LinkedBlockingQueue&lt;Runnable&gt;()</code></li>
<li><code>Executors.newSingleThreadExecutor()</code>: <code>new LinkedBlockingQueue()</code></li>
</ol>
<blockquote>
<p>以上两种创建的方式不推荐，因为使用了linkedBlockingQueue的无界队列，会导致最大线程数以及多余核心的keepalive的参数失效。 而因为无初始值的<code>new LinkedBlockingQueue()</code>是无界队列的关系，当任务过多会导致OOM</p>
</blockquote>
<ol start="3">
<li><code>Executors.newCachedThreadPool()</code>: <code>new SynchronousQueue&lt;Runnable&gt;()</code></li>
</ol>
<blockquote>
<p>不推荐用newCacheThreadPool的原因是因为最大线程数设置为Integer.MAX_VALUE,如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时，会耗尽CUP及内存。</p>
</blockquote>
<ol start="4">
<li><code>Executors.newScheduledThreadPool()</code>: <code>new DelayedWorkQueue()</code> 中封装了一个 PriorityQueue</li>
</ol>
<blockquote>
<p>任务队列 DelayedWorkQueue 封装了一个 PriorityQueue，PriorityQueue 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask 的 time 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask 的 squenceNumber 变量小的先执行)。 <br>队列原理与 DelayQueue 基本一致</p>
</blockquote>
<ol start="5">
<li><code>Executors.newWorkStealingPool()</code>: 内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</li>
</ol>
<blockquote>
<p>工作窃取算法: 工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并未每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如线程1负责处理1队列里的任务，2线程负责2队列的。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。默认从其他队列的队尾开始窃取任务执行。<br>思想为: 充分利用线程进行并行计算，减少线程间的竞争。在某些情况下还是会存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗更多的系统资源， 比如创建多个线程和多个双端队列。</p>
</blockquote>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">return new ForkJoinPool<br>       (Runtime.getRuntime().availableProcessors(),  //默认使用的是硬件的cpu数目<br>         ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>        null, true);<br></code></pre></td></tr></table></figure>

<p>队列说明: </p>
<ol>
<li><code>SynchronousQueue(CachedThreadPool)</code> 类似交警只是指挥车辆，并不管理车辆</li>
</ol>
<blockquote>
<p>SynchronousQueue没有容量，是无缓冲等待队列，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。超出直接corePoolSize个任务，直接创建新的线程来执行任务，直到(corePoolSize＋新建线程)&gt; maximumPoolSize。不是核心线程就是新建线程。</p>
</blockquote>
<ol start="2">
<li><code>LinkedBlockingQueue(single，fixed)</code>类似小仓库，暂时存储任务，待系统有空的时候再取出执行</li>
</ol>
<blockquote>
<p>BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。不指定大小的LinkedBlockingQueue是一个无界缓存等待队列。当前执行的线程数量达到corePoolSize的数量时，剩余的元素会在阻塞队列里等待。(所以在使用此阻塞队列时maximumPoolSizes就相当于无效了)，每个线程完全独立于其他线程。生产者和消费者使用独立的锁来控制数据的同步，即在高并发的情况下可以并行操作队列中的数据。</p>
</blockquote>
<ol start="3">
<li><code>ArrayBlockingQueue</code></li>
</ol>
<blockquote>
<p>ArrayBlockingQueue是一个有界缓存等待队列，可以指定缓存队列的大小，当正在执行的线程数等于corePoolSize时，多余的元素缓存在ArrayBlockingQueue队列中等待有空闲的线程时继续执行，当ArrayBlockingQueue已满时，加入ArrayBlockingQueue失败，会开启新的线程去执行，当线程数已经达到最大的maximumPoolSizes时，再有新的元素尝试加入ArrayBlockingQueue时会报错</p>
</blockquote>
<h3 id="线程池相关方法"><a href="#线程池相关方法" class="headerlink" title="线程池相关方法"></a>线程池相关方法</h3><p><code>execute()</code> VS <code>submit()</code></p>
<ul>
<li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，</li>
</ul>
<p><code>shutdown()</code> VS <code>shutdownNow()</code></p>
<ul>
<li><code>shutdown()</code>: 关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>shutdownNow()</code>: 关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<p><code>isTerminated()</code> VS <code>isShutdown()</code></p>
<ul>
<li><code>isShutDown</code> 当调用 <code>shutdown()</code> 方法后返回为 true。</li>
<li><code>isTerminated</code> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
</ul>
<h3 id="线上线程池的配置"><a href="#线上线程池的配置" class="headerlink" title="线上线程池的配置"></a>线上线程池的配置</h3><h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>CPU密集: CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。</p>
<blockquote>
<p>CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)，而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那些。</p>
</blockquote>
<p>IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<blockquote>
<p>网络读取，文件读取这类都是 IO 密集型</p>
</blockquote>
<p>对于不同性质的任务来说</p>
<ol>
<li><p>CPU密集型任务应配置尽可能小的线程，如配置CPU个数的线程数+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</p>
<blockquote>
<p>计算密(CPU)集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p>
</blockquote>
</li>
<li><p>IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1，</p>
</li>
</ol>
<blockquote>
<p>单核最佳线程数 &#x3D; <code>(1/CPU利用率)</code> &#x3D; <code>1 + (I/O耗时/CPU耗时)</code><br>最佳线程数 &#x3D; <code>CPU核心数 * (1/CPU利用率)</code> &#x3D; <code>CPU核心数 * (1 + (I/O耗时/CPU耗时))</code><br>CPU利用率: <code>(CPU耗时)/ (I/O耗时 + CPU耗时)</code></p>
</blockquote>
<p>目前所有方案:<br><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadpoolsetSolution.jpg" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<p>问题1：</p>
<blockquote>
<p>假设要求一个系统的TPS(Transaction Per Second 或者 Task Per Second)至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s<br>如何设计线程个数，使得可以在1s内处理完20个Transaction？<br>答案: 一个线程平均1s处理<code>1/4s=0.25</code>个TPS请求，<code>20/0.25=80</code>。一般服务器的CPU核数为16或者32，如果有80个线程，<strong>那么肯定会带来太多不必要的线程上下文切换开销</strong></p>
</blockquote>
<p>问题2：</p>
<blockquote>
<p>计算操作需要5ms，DB操作需要 100ms，对于一台 8 核CPU的服务器，怎么设置线程数呢？<br>答案：<code>8 * (1/(5/100+5) = 168</code> 个线程数</p>
</blockquote>
<blockquote>
<p>那如果DB的QPS(Query Per Second)上限是1000，此时这个线程数又该设置为多大呢？<br>一个线程的TPS(每秒)处理任务数 &#x3D;<code> 1000/105</code><br>系统的<code>QPS = 168 * 1000/105 &gt; 1600</code> <br>假设一个 TPS 对应一次 QPS<br>答案: 线程数 &#x3D;<code> 168* (1000/ 1600) &gt; 105</code></p>
</blockquote>
<p><strong>增加服务器核心数，与线程间的关系</strong></p>
<p><img src="https://raw.githubusercontent.com/cai-qichang/cqc-photo/master/img/threadpool1.jpg" srcset="/img/loading.gif" lazyload alt="avatar"></p>
<blockquote>
<p>假设:  1-p&#x3D;5%  而n趋近于无穷大，实际起作用的最大线程数为20。<br>临界区都是串行的，非临界区都是并行的，用单线程执行 临界区的时间&#x2F;用单线程执行(临界区+非临界区)的时间 就是串行百分比</p>
</blockquote>
<h4 id="实际执行解决方案-动态配置线程池核心线程数和最大线程数"><a href="#实际执行解决方案-动态配置线程池核心线程数和最大线程数" class="headerlink" title="实际执行解决方案: 动态配置线程池核心线程数和最大线程数"></a>实际执行解决方案: 动态配置线程池核心线程数和最大线程数</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">ThreadPoolExecutor threadPoolExecutor =  new ThreadPoolExecutor(<br>              2,5,60,<br>              TimeUnit.SECONDS,<br>              new LinkedBlockingQueue&lt;&gt;(10),Executors.defaultThreadFactory() );<br>      // 动态配置线程池核心线程数<br>      threadPoolExecutor.setCorePoolSize(10);<br>      threadPoolExecutor.setMaximumPoolSize(10);<br></code></pre></td></tr></table></figure>

<p>逻辑: </p>
<ol>
<li>首先是参数合法性校验。</li>
<li>然后用传递进来的值，覆盖原来的值。</li>
<li>判断工作线程是否是大于最大线程数，如果大于，则对空闲线程发起中断请求。</li>
</ol>
<p>注意点: </p>
<ol>
<li><p>设置核心线程数的时候，同时设置最大线程数。否则若出现核心线程数大于最大线程数，在线程池getTask的任务处理中，会因为该问题导致设置不生效。</p>
</li>
<li><p>由于LinkedBlockingQueue的容量capacity为final类型的，需要动态修改队列的容量可以通过继承该queue声明一个可改变的capacity参数。</p>
</li>
<li><p><strong>其他的tip</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">// 预启动线程池的核心线程，对线程池进行预热<br>threadPoolExecutor.prestartAllCoreThreads();<br>// 回收核心线程的一个方案允许核心线程过期<br>threadPoolExecutor.allowCoreThreadTimeOut(true);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用以下工具来了解I&#x2F;O 耗时与 CUP耗时</p>
</li>
</ol>
<ul>
<li>SkyWalking</li>
<li>CAT</li>
<li>zipkin</li>
</ul>
<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团线程池</a></li>
<li><a target="_blank" rel="noopener" href="https://dayarch.top/p/how-many-threads-should-be-created.html">日拱一兵：面试问，创建多少个线程合适？</a></li>
</ul>
<h3 id="ThreadFactory-线程工厂"><a href="#ThreadFactory-线程工厂" class="headerlink" title="ThreadFactory 线程工厂"></a>ThreadFactory 线程工厂</h3><p>ThreadFactory 主要用于创建新线程对象，使用线程工厂就无需再手工编写对 new Thread 的调用了。 </p>
<ul>
<li>对于区分业务的线程池，就可以用到到命名线程工厂的实现，针对不同线程池资源定义不同的线程名</li>
<li>或者设置一个创建守护线程的线程工厂。</li>
</ul>
<p>优点:  </p>
<ul>
<li>很容易改变的类创建的对象或我们创建这些对象的方式。</li>
<li>很容易用有限的资源限制的创建对象，例如,我们只能有N个对象。</li>
<li>很容易生成统计数据对创建的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory delegate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个带名字的线程池生产工厂</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NamingThreadFactory</span><span class="hljs-params">(ThreadFactory delegate, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.delegate = delegate;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// TODO consider uniquifying this</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> delegate.newThread(r);<br>        t.setName(name + <span class="hljs-string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Worker工作流程"><a href="#Worker工作流程" class="headerlink" title="Worker工作流程"></a>Worker工作流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs text">/**<br> * Set containing all worker threads in pool. Accessed only when<br> * holding mainLock.<br> */<br>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();<br><br><br>/**<br> * Class Worker mainly maintains interrupt control state for<br> * threads running tasks, along with other minor bookkeeping.<br> * This class opportunistically extends AbstractQueuedSynchronizer<br> * to simplify acquiring and releasing a lock surrounding each<br> * task execution.  This protects against interrupts that are<br> * intended to wake up a worker thread waiting for a task from<br> * instead interrupting a task being run.  We implement a simple<br> * non-reentrant mutual exclusion lock rather than use<br> * ReentrantLock because we do not want worker tasks to be able to<br> * reacquire the lock when they invoke pool control methods like<br> * setCorePoolSize.  Additionally, to suppress interrupts until<br> * the thread actually starts running tasks, we initialize lock<br> * state to a negative value, and clear it upon start (in<br> * runWorker).<br> */<br>private final class Worker<br>    extends AbstractQueuedSynchronizer<br>    implements Runnable &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Worker为线程池内部对于线程的包装类，继承了AQS抽象类，实现了简单的不可重入的互斥锁。</p>
<ol>
<li>使用AQS框架提供对线程的中断控制。</li>
<li>不可重入互斥，保证了在runWorker方法中执行的线程安全。 主要为了防止自我中断的现象发生。<ol>
<li>因为RunWorker方法中存在beforeExecute、afterExecute的空插槽方法，若方法重写后调用了<code>setCorePoolSize()</code>, 使用ReentrantLock会导致线程可重入，进而导致自我中断的现象发生。</li>
<li>另外线程中的实际执行方法也可能调用 <code>setCorePoolSize()</code>。</li>
</ol>
</li>
<li>Worker使用HashSet进行保存，通过ReentrantLock方法保证线程安全，控制Worker集合的修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>                w.lock();<br><span class="hljs-comment">//                ...</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 空的插槽方法</span><br>                    beforeExecute(wt, task);<br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        thrown = x;<br>                        <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x;<br>                        <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// 空的插槽方法</span><br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Worker-线程复用"><a href="#Worker-线程复用" class="headerlink" title="Worker 线程复用"></a>Worker 线程复用</h4><p>线程复用主要通过while循环的去队列中获取任务<code>getTask()</code></p>
<ol>
<li>因为队列为阻塞队列，若为核心线程直接调用阻塞队列的take()方法。</li>
<li>若目前线程数超过核心线程，那么使用<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>，未获取到新任务推出线程的while方法，进入销毁流程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//         ...</span><br>            &#125;<br><span class="hljs-comment">//         ...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>            <span class="hljs-comment">// Are workers subject to culling?</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>            <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>                    &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>                <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                        workQueue.take();<br>                <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                timedOut = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>                timedOut = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="超数量线程的销毁"><a href="#超数量线程的销毁" class="headerlink" title="超数量线程的销毁"></a>超数量线程的销毁</h4><ol>
<li>超过核心线程数的线程在通过<code>getTask()</code>方法中通过使用<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>未获取到线程的</li>
<li>退出线程的while方法，进而进入到销毁流程。</li>
<li>销毁线程通过ReentrantLock获取WorkerSet的操作权限，进而移除线程。</li>
</ol>
<h4 id="相关资料-1"><a href="#相关资料-1" class="headerlink" title="相关资料"></a>相关资料</h4><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42189195/why-threadpoolexecutorworker-extends-abstractqueuedsynchronizer">Worker继承AQS的原因</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a8c81066201">彻底理解Java线程池原理篇</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuzhihu/p/8177371.html">深入理解Java线程池: ThreadPoolExecutor</a></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>Thread 类存储了ThreadLocal.ThreadLocalMap 对象 : <code>ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</code></p>
<ul>
<li>key: key视作ThreadLocal，value为代码中放入的值(实际上key并不是ThreadLocal本身，而是它的一个弱引用WeakReference).</li>
<li>ThreadLocalMap的key为每个新建的<code>ThreadLocal private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; &#125;</code></li>
</ul>
<p>ThreadMap的实现类似于HashMap，不过其数据结构仅使用数组，定义一个Entry的类，key为 WeakReference引用的ThreadLocal，value为存入的value。</p>
<ul>
<li>key的hash计算: 使用黄金分割数*AtomInteger计算，再根据容量确定索引位置。每次新增一个元素，AtomInteger都自动加一。</li>
<li>因为map的key都是threadLocal，所以在不set或remove元素的时候，每次get都是同一个元素的值。</li>
</ul>
<p>set元素逻辑: </p>
<ol>
<li>hash定位到数组索引位置，如果位置无元素直接设值。</li>
<li>如果存在元素对比当前Entry key的hash 是否一致，一致则直接替换元素。</li>
<li>若不一致，向后一次找一个空位。</li>
</ol>
<p>TheadMap的key为weakReference包裹的threadLocal  因此会存在被jvm回收的情况。使用在set的时如果遇到Entry是被回收的值，则触发探测性清理。</p>
<ul>
<li>探测性清理: 以当前Entry 向后迭代查找，遇到为null则结束清理，遇到entry为空的值，清空数组位置，size–。非空的entry计算重哈希的位置。</li>
<li>启发性清理: 向后递归查找一个过期的位置，找到过期的位置触发探测性清理。</li>
</ul>
<p>扩容:  扩容后的tab的大小为oldLen * 2，然后遍历老的散列表，重新计算hash位置，然后放到新的tab数组中，</p>
<blockquote>
<p>在扩容、get和set的过程中遇到过期的键都会触发探测性清理。</p>
</blockquote>
<h3 id="父线程与子线程传递threadLocal的方案"><a href="#父线程与子线程传递threadLocal的方案" class="headerlink" title="父线程与子线程传递threadLocal的方案"></a>父线程与子线程传递threadLocal的方案</h3><ol>
<li>阿里巴巴提供TransmittableThreadLocal组件: 父线程与子线程传递threadLocal的方案</li>
<li>InheritableThreadLocal:  父线程与子线程共享threadLocal的方案，new Thread的时候会传递InheritableThreadLocal的解决方案。</li>
</ol>
<blockquote>
<p>缺陷需要在父线程中调用new Thread传递，而使用中新建线程都是使用线程池技术。</p>
</blockquote>
<h3 id="ThreadLocal应用"><a href="#ThreadLocal应用" class="headerlink" title="ThreadLocal应用"></a>ThreadLocal应用</h3><blockquote>
<p>存在一个线程经常遇到横跨若干方法调用，需要传递的对象，也就是上下文(Context)，它是一种状态，经常就是是用户身份、任务信息等，就会存在过渡传参的问题。</p>
</blockquote>
<p><strong>Spring 事务应用</strong></p>
<ul>
<li>Spring采用ThreadLocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</li>
<li>Spring框架里面就是用的ThreadLocal来实现这种隔离，主要是在TransactionSynchronizationManager这个类里面.</li>
<li>spring security 使用ThreadLocal 存储是否请求是否已经认证。</li>
</ul>
<p><strong>读写分离实现</strong></p>
<ul>
<li>使用theadLocal获取当前需要执行的数据源，结合AbstractDataSourceRouter执行需要执行的数据库。</li>
</ul>
<p><strong>ThreadLocalRandom</strong> 是ThreadLocal与 Random的结合，在Random的基础上进行性能的优化，在并发的情况下提供较大的性能提升。</p>
<blockquote>
<p>Random 也是线程安全的类，内部使用AtomLong 结合 CAS技术实现，但是CAS技术在并发的情况下，性能比较糟糕。<br>ThreadLocalRandom 是通过为每个线程实例化一个随机数生成器，来减少系统开销和对资源的争用。</p>
</blockquote>
<p><strong>跨方法传递</strong>: 常规web服务接收到request的时候，经常有一些用户信息需要传递到service层。此时就可以使用ThreadLocal存储用户信息，每个service方法就不用写传递参数。</p>
<h3 id="TheadLocal-与-SimpleDateFormat的应用"><a href="#TheadLocal-与-SimpleDateFormat的应用" class="headerlink" title="TheadLocal 与 SimpleDateFormat的应用"></a>TheadLocal 与 SimpleDateFormat的应用</h3><p>使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()，然后调用Calendar.add()，如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。</p>
<p>解决: 使用了线程池加上ThreadLocal包装SimpleDataFormat，再调用initialValue让每个线程有一个SimpleDataFormat的副本，从而解决了线程安全的问题，也提高了性能。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormat = ThreadLocal.withInitial(() -&gt;<br>    new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)<br>);<br></code></pre></td></tr></table></figure>

<p><strong>如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat, 线程安全</strong></p>
<h3 id="相关资料-2"><a href="#相关资料-2" class="headerlink" title="相关资料"></a>相关资料</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LzkZXPtLW2dqPoz3kh3pBQ">Java面试必问: ThreadLocal终极篇 淦</a></p>
<p>待补充资料: netty的fastThreadLocal</p>
<h2 id="spring-中的线程池"><a href="#spring-中的线程池" class="headerlink" title="spring 中的线程池"></a>spring 中的线程池</h2><p>如果我们需要在 SpringBoot 实现异步编程的话，通过 Spring 提供的两个注解会让这件事情变的非常简单。</p>
<ul>
<li>@EnableAsync: 通过在配置类或者Main类上加@EnableAsync开启对异步方法的支持。</li>
<li>@Async 可以作用在类上或者方法上，作用在类上代表这个类的所有方法都是异步方法。</li>
</ul>
<blockquote>
<p>没有自定义Executor, Spring 将创建一个 SimpleAsyncTaskExecutor 并使用它。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">@Bean<br>public Executor taskExecutor() &#123;<br>    // Spring 默认配置是核心线程数大小为1，最大线程容量大小不受限制，队列容量也不受限制。<br>    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br>    executor.setCorePoolSize(CORE_POOL_SIZE);<br>    executor.setMaxPoolSize(MAX_POOL_SIZE);<br>    executor.setQueueCapacity(QUEUE_CAPACITY);<br>    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<br>    executor.setThreadNamePrefix(&quot;My ThreadPoolTaskExecutor-&quot;);<br>    executor.initialize();<br>    return executor;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="异步编程demo"><a href="#异步编程demo" class="headerlink" title="异步编程demo"></a>异步编程demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">completableFutureTask</span><span class="hljs-params">(String start)</span> &#123;<br>        <span class="hljs-comment">// 打印日志</span><br>        logger.warn(Thread.currentThread().getName() + <span class="hljs-string">&quot;start this task!&quot;</span>);<br>        <span class="hljs-comment">// 找到特定字符/字符串开头的电影</span><br>        List&lt;String&gt; results =<br>                movies.stream().filter(movie -&gt; movie.startsWith(start)).collect(Collectors.toList());<br>        <span class="hljs-comment">// 模拟这是一个耗时的任务</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//返回一个已经用给定值完成的新的CompletableFuture。</span><br>        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(results);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用方法</span><br>    <span class="hljs-meta">@GetMapping(&quot;/movies&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">completableFutureTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 开始执行大量的异步任务</span><br>        List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;T&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>        List&lt;CompletableFuture&lt;List&lt;String&gt;&gt;&gt; completableFutureList =<br>                words.stream()<br>                        .map(word -&gt; asyncService.completableFutureTask(word))<br>                        .collect(Collectors.toList());<br>        <span class="hljs-comment">// CompletableFuture.join()方法可以获取他们的结果并将结果连接起来</span><br>        List&lt;List&lt;String&gt;&gt; results = completableFutureList.stream().map(CompletableFuture::join).collect(Collectors.toList());<br>        <span class="hljs-comment">// 打印结果以及运行程序运行花费时间</span><br>        System.out.println(<span class="hljs-string">&quot;Elapsed time: &quot;</span> + (System.currentTimeMillis() - start));<br>        <span class="hljs-keyword">return</span> results.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/" class="category-chain-item">Java并发相关</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java%E7%BA%BF%E7%A8%8B/" class="print-no-link">#Java线程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java线程</div>
      <div>https://cai-qichang.github.io/2022/09/22/Java线程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>caiqichang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月22日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              BY-蔡奇倡
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/22/Java%E5%B9%B6%E5%8F%91-%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java并发(虚拟机)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java并发(虚拟机)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/22/Mybatis/" title="Mybatis">
                        <span class="hidden-mobile">Mybatis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      粤ICP备2021019144号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
